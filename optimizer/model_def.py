from pyomo.environ import *
from pyomo.core import sum_product

# Model definition
model = AbstractModel()

# Sets
model.E = Set()                                                                 # Employees
model.D = Set(initialize=["Mon", "Tue", "Wed", "Thur", "Fri", "Sat", "Sun"])    # DaysOfWeek
model.S = Set(initialize=[i for i in range(1, 6)])                              # dummy data, needs fix

# Parameters
model.n = Param()   # No. of employees
model.m = Param()   # No. of shifts
model.time_open = Param()
model.time_close = Param()

def business_hours_rule(model):
    time_open = model.time_open.value
    time_close = model.time_close.value
    if time_close > time_open:
        return time_close - time_open
    else:
        return time_close - time_open + 24
model.BusinessHours = Param(initialize=business_hours_rule)
#model.BusinessHours = Expression(rule=business_hours_rule)

def shift_hours_rule(model):
    n_shift = model.m.value
    h_hours = model.BusinessHours()
    return int(h_hours / n_shift)
model.ShiftHours = Param(initialize=shift_hours_rule)
#model.ShiftHours = Expression(rule=shift_hours_rule)


# Matrices generated by LLM
model.M_LLM_ED = Param(model.E, model.D, model.S, domain=Reals)
model.M_LLM_EE = Param(model.E, model.E, domain=Reals)

# Suggested matrices
model.A = Var(model.E, model.D, model.S, domain=Binary)
model.M_sugg_EE = Var(model.E, model.E, domain=Reals, bounds=(-1, 1))

# Constrains
@model.Constraint(model.D, model.S)
def two_workers_per_shift(model, d, s):
    # Two workers should be assigned to each shift
    return sum(model.A[e, d, s] for e in model.E) == 2

@model.Constraint(model.E)
def minimum_shift_per_week(model, e):
    # Each worker should work at least one shift
    return sum(sum(model.A[e, d, s] for s in model.S) for d in model.D) >= 1

@model.Constraint(model.E)
def fourty_hours_per_week(model, e):
    # Each worker should work less than 40 hours per week
    h_shift = model.ShiftHours.value
    #h_shift = model.ShiftHours()
    return sum((sum(model.A[e, d, s] for s in model.S) * h_shift) for d in model.D) <= 40

@model.Constraint(model.E, model.D)
def eight_hours_per_day_rule(model, e, d):
    # Each worker shoud less than 8 hours per day
    h_shift = model.ShiftHours.value
    #h_shift = model.ShiftHours()
    return sum(model.A[e, d, s] for s in model.S) * h_shift <= 8

# Objective function and supplements
# ED Matrix
# Elemement-wise difference
#def ED_Element_Rule(m):
#    return (1 / (len(m.E) * len(m.D) * len(m.S))) * summation(m.A - m.M_LLM_ED, index=m.E * m.D * m.S)
def ED_Element_Rule(m):
    return (1 / (len(m.E) * len(m.D) * len(m.S))) * sum(
        (m.A[e, d, s] - m.M_LLM_ED[e, d, s]) 
        for e in m.E for d in m.D for s in m.S
    )
model.ED_Element_diff = Expression(rule=ED_Element_Rule)

# Employee-wise difference
def ED_DotProduct_Per_Employee_Rule(m):
    return sum(
            sum(
            m.A[e, d, s] * m.M_LLM_ED[e, d, s]
            for d in m.D for s in m.S
        )
        for e in model.E
    )
model.ED_DotProduct_Per_Employee = Expression(rule=ED_DotProduct_Per_Employee_Rule)

def ED_L2Norm_Employee_Rule(m):
    return sum(# Summing for all E
        sqrt(sum(m.A[e, d, s]**2 for s in model.S for d in model.D))            # A
        * sqrt(sum(m.M_LLM_ED[e, d, s]**2 for s in model.S for d in model.D))   # M_LLM_ED
        for e in model.E
    )
model.ED_Employee_demoninator = Expression(rule=ED_L2Norm_Employee_Rule)

def ED_Employee_CosSim_Rule(m):
    return m.ED_DotProduct_Per_Employee / m.ED_Employee_demoninator
model.ED_Employee_diff = Expression(rule=ED_Employee_CosSim_Rule)

# Whole matrix difference
def ED_DotProduct_Rule(m):
    return sum_product(m.A, m.M_LLM_ED)
model.ED_DotProduct = Expression(rule=ED_DotProduct_Rule)

def L2Norm_A_Rule(m):
    sum_of_square = summation(m.A**2, index=m.E * m.D * m.S)
    return sqrt(sum_of_square)
model.L2Norm_A = Expression(rule=L2Norm_A_Rule)

def L2Norm_M_LLM_ED_Rule(m):
    sum_of_square = summation(m.M_LLM_ED**2, index=m.E * m.D * m.S)
    return sqrt(sum_of_square)
model.L2Norm_M_LLM_ED = Expression(rule=L2Norm_M_LLM_ED_Rule)

def ED_CosSim_Rule(m):
    return m.ED_DotProduct / (m.L2Norm_A * m.L2Norm_M_LLM_ED)
model.ED_diff = Expression(rule=ED_CosSim_Rule)

def ED_Loss_Rule(m):
    return m.ED_Element_diff + m.ED_Employee_diff + m.ED_diff
model.ED_Loss = Expression(rule=ED_Loss_Rule)

# EE Matrix
# Element-wise difference
def EE_Element_Rule(m):
    return (1 / (len(m.E) * len(m.E))) * summation(m.M_sugg_EE - m.M_LLM_EE, index=m.E * m.E)
model.EE_Element_diff = Expression(rule=EE_Element_Rule)

# Employee-wise difference
def EE_DotProduct_Per_Employee_Rule(m):
    return sum(
        m.M_sugg_EE[e, e_] * m.M_LLM_EE[e, e_]
        for e in m.E for e_ in m.E 
    )
model.EE_DotProduct_Per_Employee = Expression(rule=EE_DotProduct_Per_Employee_Rule)

def EE_L2Norm_Employee_Rule(m):
    return sum(
        sqrt(sum(m.M_sugg_EE[e, e_]**2 for e_ in model.E))            # M_sugg_EE
        * sqrt(sum(m.M_LLM_EE[e, e_]**2 for e_ in model.E))           # M_LLM_EE
        for e in model.E
    )
model.EE_Employee_demoninator = Expression(rule=EE_L2Norm_Employee_Rule)

def EE_Employee_CosSim_Rule(m):
    return m.EE_DotProduct_Per_Employee / m.EE_Employee_demoninator
model.EE_Employee_diff = Expression(rule=EE_Employee_CosSim_Rule)

# Whole matrix difference
def EE_DotProduct_Rule(m):
    return sum_product(m.M_sugg_EE, m.M_LLM_EE)
model.EE_DotProduct = Expression(rule=EE_DotProduct_Rule)

def L2Norm_M_sugg_EE_Rule(m):
    sum_of_square = summation(m.M_sugg_EE**2, index=m.E * m.E)
    return sqrt(sum_of_square)
model.L2Norm_M_sugg_EE = Expression(rule=L2Norm_M_sugg_EE_Rule)

def L2Norm_M_LLM_EE_Rule(m):
    sum_of_square = summation(m.M_LLM_EE**2, index=m.E * m.E)
    return sqrt(sum_of_square)
model.L2Norm_M_LLM_EE = Expression(rule=L2Norm_M_LLM_EE_Rule)

def EE_CosSim_Rule(m):
    return m.EE_DotProduct / (m.L2Norm_M_sugg_EE * m.L2Norm_M_LLM_EE)
model.EE_diff = Expression(rule=EE_CosSim_Rule)

def EE_Loss_Rule(m):
    return m.EE_Element_diff + m.EE_Employee_diff + m.EE_diff
model.EE_Loss = Expression(rule=EE_Loss_Rule)

# Objective function
@model.Objective(sense=minimize)
def minimize_oss(m):
    return m.ED_Loss + m.EE_Loss