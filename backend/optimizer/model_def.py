from pyomo.environ import *
from pyomo.environ import value, sqrt

# constant (preventing divided by zero error)
EPS = 1e-4

# Model definition
model = AbstractModel()

# Sets
model.E = Set()                                                                 # Employees
model.D = Set(initialize=["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"])    # DaysOfMonth
model.S = Set(initialize=[i for i in range(1, 3)])                              # morning, evening

# Parameters
model.n = Param(model.E, default=0)   # No. of employees (indexed for safeness)
model.m = Param(initialize=2)   # No. of shifts

def business_hours_rule(model):
    time_open = model.time_open.value
    else:
        return time_close - time_open + 24
model.time_open = Param(default=9)
model.time_close = Param(default=17)
model.BusinessHours = Param(initialize=business_hours_rule)

def shift_hours_rule(model):
    n_shift = model.m
    h_hours = model.BusinessHours
    except Exception:
        return 8
model.ShiftHours = Param(initialize=shift_hours_rule)

# Matrices generated by LLM
model.M_LLM_ED = Param(model.E, model.D, model.S, domain=Reals, default=0)
model.M_LLM_EE = Param(model.E, model.E, domain=Reals, default=0)

# Suggested matrices
model.A = Var(model.E, model.D, model.S, domain=Binary)
model.M_sugg_EE = Var(model.E, model.E, domain=Reals, bounds=(-1, 1))

# Constrains
@model.Constraint(model.D, model.S)
def two_workers_per_shift(model, d, s):
    return sum(model.A[e, d, s] for e in model.E) == 2

@model.Constraint(model.E)
def minimum_shift_per_week(model, e):
    return sum(sum(model.A[e, d, s] for s in model.S) for d in model.D) >= 1

@model.Constraint(model.E)
def fourty_hours_per_week(model, e):
    h_shift = value(model.ShiftHours)
    return sum((sum(model.A[e, d, s] for s in model.S) * h_shift) for d in model.D) <= 40

@model.Constraint(model.E, model.D)
def eight_hours_per_day_rule(model, e, d):
    h_shift = value(model.ShiftHours)
    return sum(model.A[e, d, s] for s in model.S) * h_shift <= 8

# Objective function and supplements
# ED Matrix
# Elemement-wise difference
def ED_Element_Rule(m):
    return (1 / (len(m.E) * len(m.D) * len(m.S))) * sum(
        (m.A[e, d, s] - m.M_LLM_ED[e, d, s]) 
        for e in m.E for d in m.D for s in m.S
    )
model.ED_Element_diff = Expression(rule=ED_Element_Rule)

# Employee-wise difference
def ED_DotProduct_Per_Employee_Rule(m, e):
    return sum(m.A[e, d, s] * m.M_LLM_ED[e, d, s] for d in m.D for s in m.S)
model.ED_DotProduct_Per_Employee = Expression(model.E, rule=ED_DotProduct_Per_Employee_Rule)

def ED_L2Norm_Employee_Rule(m, e):
    return sqrt(sum(m.A[e, d, s]**2 for d in m.D for s in m.S)) * \
           sqrt(sum(m.M_LLM_ED[e, d, s]**2 for d in m.D for s in m.S))
model.ED_Employee_denominator = Expression(model.E, rule=ED_L2Norm_Employee_Rule)

def ED_Employee_CosSim_Rule(m, e):
    return m.ED_DotProduct_Per_Employee[e] / (m.ED_Employee_denominator[e] + EPS)
model.ED_Employee_diff = Expression(model.E, rule=ED_Employee_CosSim_Rule)

# Whole matrix difference
def ED_DotProduct_Rule(m):
    return sum(
        m.A[e, d, s] * m.M_LLM_ED[e, d, s]
        for e in m.E for d in m.D for s in m.S
    )
model.ED_DotProduct = Expression(rule=ED_DotProduct_Rule)

def L2Norm_A_Rule(m):
    sum_of_square = sum(m.A[e, d, s]**2 for e in m.E for d in m.D for s in m.S)
    return sqrt(sum_of_square)
model.L2Norm_A = Expression(rule=L2Norm_A_Rule)

def L2Norm_M_LLM_ED_Rule(m):
    sum_of_square = sum(
        (m.M_LLM_ED[e, d, s])**2
        for e in m.E for d in m.D for s in m.S
    )
    return sqrt(sum_of_square)
model.L2Norm_M_LLM_ED = Expression(rule=L2Norm_M_LLM_ED_Rule)

def ED_CosSim_Rule(m):
    return m.ED_DotProduct / (m.L2Norm_A * m.L2Norm_M_LLM_ED + EPS)
model.ED_diff = Expression(rule=ED_CosSim_Rule)

def ED_Loss_Rule(m):
    return m.ED_Element_diff + sum(m.ED_Employee_diff[e] for e in m.E) + m.ED_diff
model.ED_Loss = Expression(rule=ED_Loss_Rule)

# EE Matrix
# Element-wise difference
def EE_Element_Rule(m):
    return (1 / (len(m.E) * len(m.E))) * sum(
        (m.M_sugg_EE[e, e_] - m.M_LLM_EE[e, e_])
        for e in m.E for e_ in m.E
    )
model.EE_Element_diff = Expression(rule=EE_Element_Rule)

# Employee-wise difference
def EE_DotProduct_Per_Employee_Rule(m):
    return sum(
        m.M_sugg_EE[e, e_] * m.M_LLM_EE[e, e_]
        for e in m.E for e_ in m.E 
    )
model.EE_DotProduct_Per_Employee = Expression(rule=EE_DotProduct_Per_Employee_Rule)

def EE_L2Norm_Employee_Rule(m, e):
    return sqrt(sum(m.M_sugg_EE[e, e_]**2 for e_ in m.E)) * \
           sqrt(sum(m.M_LLM_EE[e, e_]**2 for e_ in m.E))
model.EE_Employee_denominator = Expression(model.E, rule=EE_L2Norm_Employee_Rule)

def EE_Employee_CosSim_Rule(m, e):
    return m.EE_DotProduct_Per_Employee / (m.EE_Employee_denominator[e] + EPS)
model.EE_Employee_diff = Expression(model.E, rule=EE_Employee_CosSim_Rule)

# Whole matrix difference
def EE_DotProduct_Rule(m):
    return sum(
        m.M_sugg_EE[e, e_] * m.M_LLM_EE[e, e_]
        for e in m.E for e_ in m.E
    )
model.EE_DotProduct = Expression(rule=EE_DotProduct_Rule)

def L2Norm_M_sugg_EE_Rule(m):
    sum_of_square = sum(
        m.M_sugg_EE[e, e_]**2
        for e in m.E for e_ in m.E
    )
    return sqrt(sum_of_square)
model.L2Norm_M_sugg_EE = Expression(rule=L2Norm_M_sugg_EE_Rule)

def L2Norm_M_LLM_EE_Rule(m):
    sum_of_square = sum(
        (m.M_LLM_EE[e, e_])**2
        for e in m.E for e_ in m.E
    )
    return sqrt(sum_of_square)
model.L2Norm_M_LLM_EE = Expression(rule=L2Norm_M_LLM_EE_Rule)

def EE_CosSim_Rule(m):
    return m.EE_DotProduct / (m.L2Norm_M_sugg_EE * m.L2Norm_M_LLM_EE + EPS)
model.EE_diff = Expression(rule=EE_CosSim_Rule)

def EE_Loss_Rule(m):
    return m.EE_Element_diff + sum(m.EE_Employee_diff[e] for e in m.E) + m.EE_diff
model.EE_Loss = Expression(rule=EE_Loss_Rule)

# Objective function
@model.Objective(sense=minimize)
def minimize_oss(m):
    return m.ED_Loss + m.EE_Loss

from pyomo.environ import *
from pyomo.environ import value, sqrt

# constant (preventing divided by zero error)
EPS = 1e-4

# Model definition
model = AbstractModel()

# Sets
model.E = Set()                                                                 # Employees
model.D = Set(initialize=["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"])    # DaysOfMonth
model.S = Set(initialize=[i for i in range(1, 3)])                              # morning, evening

# Parameters
model.n = Param(model.E, default=0)   # No. of employees (indexed for safeness)
model.m = Param(initialize=2)   # No. of shifts

def business_hours_rule(model):
    time_open = model.time_open.value
    time_close = model.time_close.value
    if time_close > time_open:
        return time_close - time_open
    else:
        return time_close - time_open + 24
model.time_open = Param(default=9)
model.time_close = Param(default=17)
model.BusinessHours = Param(initialize=business_hours_rule)

def shift_hours_rule(model):
    n_shift = model.m
    h_hours = model.BusinessHours
    try:
        return int(value(h_hours) / int(value(n_shift)))
    except Exception:
        return 8
model.ShiftHours = Param(initialize=shift_hours_rule)

# Matrices generated by LLM
model.M_LLM_ED = Param(model.E, model.D, model.S, domain=Reals, default=0)
model.M_LLM_EE = Param(model.E, model.E, domain=Reals, default=0)

# Suggested matrices
model.A = Var(model.E, model.D, model.S, domain=Binary)
model.M_sugg_EE = Var(model.E, model.E, domain=Reals, bounds=(-1, 1))

# Constrains
@model.Constraint(model.D, model.S)
def two_workers_per_shift(model, d, s):
    # Two workers should be assigned to each shift
    return sum(model.A[e, d, s] for e in model.E) == 2

@model.Constraint(model.E)
def minimum_shift_per_week(model, e):
    # Each worker should work at least one shift
    return sum(sum(model.A[e, d, s] for s in model.S) for d in model.D) >= 1

@model.Constraint(model.E)
def fourty_hours_per_week(model, e):
    # Each worker should work less than 40 hours per week
    h_shift = value(model.ShiftHours)
    return sum((sum(model.A[e, d, s] for s in model.S) * h_shift) for d in model.D) <= 40

@model.Constraint(model.E, model.D)
def eight_hours_per_day_rule(model, e, d):
    # Each worker shoud less than 8 hours per day
    h_shift = value(model.ShiftHours)
    return sum(model.A[e, d, s] for s in model.S) * h_shift <= 8

# Objective function and supplements
# ED Matrix
# Elemement-wise difference
def ED_Element_Rule(m):
    return (1 / (len(m.E) * len(m.D) * len(m.S))) * sum(
        (m.A[e, d, s] - m.M_LLM_ED[e, d, s]) 
        for e in m.E for d in m.D for s in m.S
    )
model.ED_Element_diff = Expression(rule=ED_Element_Rule)

# Employee-wise difference
def ED_DotProduct_Per_Employee_Rule(m, e):
    return sum(m.A[e, d, s] * m.M_LLM_ED[e, d, s] for d in m.D for s in m.S)
model.ED_DotProduct_Per_Employee = Expression(model.E, rule=ED_DotProduct_Per_Employee_Rule)

def ED_L2Norm_Employee_Rule(m, e):
    return sqrt(sum(m.A[e, d, s]**2 for d in m.D for s in m.S)) * \
           sqrt(sum(m.M_LLM_ED[e, d, s]**2 for d in m.D for s in m.S))
model.ED_Employee_denominator = Expression(model.E, rule=ED_L2Norm_Employee_Rule)

def ED_Employee_CosSim_Rule(m, e):
    return m.ED_DotProduct_Per_Employee[e] / (m.ED_Employee_denominator[e] + EPS)
model.ED_Employee_diff = Expression(model.E, rule=ED_Employee_CosSim_Rule)

# Whole matrix difference
def ED_DotProduct_Rule(m):
    return sum(
        m.A[e, d, s] * m.M_LLM_ED[e, d, s]
        for e in m.E for d in m.D for s in m.S
    )
model.ED_DotProduct = Expression(rule=ED_DotProduct_Rule)

def L2Norm_A_Rule(m):
    sum_of_square = sum(m.A[e, d, s]**2 for e in m.E for d in m.D for s in m.S)
    return sqrt(sum_of_square)
model.L2Norm_A = Expression(rule=L2Norm_A_Rule)

def L2Norm_M_LLM_ED_Rule(m):
    sum_of_square = sum(
        (m.M_LLM_ED[e, d, s])**2
        for e in m.E for d in m.D for s in m.S
    )
    return sqrt(sum_of_square)
model.L2Norm_M_LLM_ED = Expression(rule=L2Norm_M_LLM_ED_Rule)

def ED_CosSim_Rule(m):
    return m.ED_DotProduct / (m.L2Norm_A * m.L2Norm_M_LLM_ED + EPS)
model.ED_diff = Expression(rule=ED_CosSim_Rule)

def ED_Loss_Rule(m):
    return m.ED_Element_diff + sum(m.ED_Employee_diff[e] for e in m.E) + m.ED_diff
model.ED_Loss = Expression(rule=ED_Loss_Rule)

# EE Matrix
# Element-wise difference
def EE_Element_Rule(m):
    return (1 / (len(m.E) * len(m.E))) * sum(
        (m.M_sugg_EE[e, e_] - m.M_LLM_EE[e, e_])
        for e in m.E for e_ in m.E
    )
model.EE_Element_diff = Expression(rule=EE_Element_Rule)

# Employee-wise difference
def EE_DotProduct_Per_Employee_Rule(m):
    return sum(
        m.M_sugg_EE[e, e_] * m.M_LLM_EE[e, e_]
        for e in m.E for e_ in m.E 
    )
model.EE_DotProduct_Per_Employee = Expression(rule=EE_DotProduct_Per_Employee_Rule)

def EE_L2Norm_Employee_Rule(m, e):
    return sqrt(sum(m.M_sugg_EE[e, e_]**2 for e_ in m.E)) * \
           sqrt(sum(m.M_LLM_EE[e, e_]**2 for e_ in m.E))
model.EE_Employee_denominator = Expression(model.E, rule=EE_L2Norm_Employee_Rule)

def EE_Employee_CosSim_Rule(m, e):
    return m.EE_DotProduct_Per_Employee / (m.EE_Employee_denominator[e] + EPS)
model.EE_Employee_diff = Expression(model.E, rule=EE_Employee_CosSim_Rule)

# Whole matrix difference
def EE_DotProduct_Rule(m):
    return sum(
        m.M_sugg_EE[e, e_] * m.M_LLM_EE[e, e_]
        for e in m.E for e_ in m.E
    )
model.EE_DotProduct = Expression(rule=EE_DotProduct_Rule)

def L2Norm_M_sugg_EE_Rule(m):
    sum_of_square = sum(
        m.M_sugg_EE[e, e_]**2
        for e in m.E for e_ in m.E
    )
    return sqrt(sum_of_square)
model.L2Norm_M_sugg_EE = Expression(rule=L2Norm_M_sugg_EE_Rule)

def L2Norm_M_LLM_EE_Rule(m):
    sum_of_square = sum(
        (m.M_LLM_EE[e, e_])**2
        for e in m.E for e_ in m.E
    )
    return sqrt(sum_of_square)
model.L2Norm_M_LLM_EE = Expression(rule=L2Norm_M_LLM_EE_Rule)

def EE_CosSim_Rule(m):
    return m.EE_DotProduct / (m.L2Norm_M_sugg_EE * m.L2Norm_M_LLM_EE + EPS)
model.EE_diff = Expression(rule=EE_CosSim_Rule)

def EE_Loss_Rule(m):
    return m.EE_Element_diff + sum(m.EE_Employee_diff[e] for e in m.E) + m.EE_diff
model.EE_Loss = Expression(rule=EE_Loss_Rule)

# Objective function
@model.Objective(sense=minimize)
def minimize_oss(m):
    return m.ED_Loss + m.EE_Loss